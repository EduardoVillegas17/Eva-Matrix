import { Api } from "../tl";
import type { Message } from "../tl/custom/message";
import type { DateLike, EntityLike, FileLike, MarkupLike, MessageIDLike, MessageLike } from "../define";
import { RequestIter } from "../requestIter";
import { TotalList } from "../Helpers";
import type { TelegramClient } from "../";
interface MessageIterParams {
    entity: EntityLike;
    offsetId: number;
    minId: number;
    maxId: number;
    fromUser?: EntityLike;
    offsetDate: DateLike;
    addOffset: number;
    filter: any;
    search: string;
    replyTo: MessageIDLike;
}
export declare class _MessagesIter extends RequestIter {
    entity?: Api.TypeInputPeer;
    request?: Api.messages.SearchGlobal | Api.messages.GetReplies | Api.messages.GetHistory | Api.messages.Search;
    fromId?: number;
    addOffset?: number;
    maxId?: number;
    minId?: number;
    lastId?: number;
    _init({ entity, offsetId, minId, maxId, fromUser, offsetDate, addOffset, filter, search, replyTo, }: MessageIterParams): Promise<false | undefined>;
    _loadNextChunk(): Promise<true | undefined>;
    _messageInRange(message: Message): boolean;
    [Symbol.asyncIterator](): AsyncIterator<Message, any, undefined>;
    _updateOffset(lastMessage: Message, response: any): void;
}
interface IDsIterInterface {
    entity: EntityLike;
    ids: Api.TypeInputMessage[];
}
export declare class _IDsIter extends RequestIter {
    _ids?: Api.TypeInputMessage[];
    _offset?: number;
    _ty: number | undefined;
    private _entity;
    _init({ entity, ids }: IDsIterInterface): Promise<void>;
    [Symbol.asyncIterator](): AsyncIterator<Message, any, undefined>;
    _loadNextChunk(): Promise<false | undefined>;
}
export interface IterMessagesParams {
    limit?: number;
    offsetDate?: DateLike;
    offsetId?: number;
    maxId?: number;
    minId?: number;
    addOffset?: number;
    search?: string;
    filter?: Api.TypeMessagesFilter | Api.TypeMessagesFilter[];
    fromUser?: EntityLike;
    waitTime?: number;
    ids?: number | number[];
    reverse?: boolean;
    replyTo?: number;
}
export interface SendMessageParams {
    message: MessageLike;
    replyTo?: number | Api.Message;
    parseMode?: any;
    formattingEntities?: Api.TypeMessageEntity[];
    linkPreview?: boolean;
    file?: FileLike | FileLike[];
    forceDocument?: false;
    clearDraft?: false;
    buttons?: MarkupLike;
    silent?: boolean;
    schedule?: DateLike;
}
export interface EditMessageParams {
    message: Api.Message | number;
    text: string;
    parseMode?: any;
    formattingEntities?: Api.TypeMessageEntity[];
    linkPreview?: boolean;
    file?: FileLike | FileLike[];
    forceDocument?: false;
    buttons?: MarkupLike;
    schedule?: DateLike;
}
export declare function iterMessages(client: TelegramClient, entity: EntityLike | undefined, { limit, offsetDate, offsetId, maxId, minId, addOffset, search, filter, fromUser, waitTime, ids, reverse, replyTo, }: IterMessagesParams): _MessagesIter | _IDsIter;
export declare function getMessages(client: TelegramClient, entity: EntityLike | undefined, params: IterMessagesParams): Promise<TotalList<Message>>;
export declare function sendMessage(client: TelegramClient, entity: EntityLike, { message, replyTo, parseMode, formattingEntities, linkPreview, file, forceDocument, clearDraft, buttons, silent, schedule, }: SendMessageParams): Promise<Api.TypeUpdates>;
/**
 * Used to edit a message by changing it's text or media
 * message refers to the message to be edited not what to edit
 * text refers to the new text
 */
export declare function editMessage(client: TelegramClient, entity: EntityLike, { message, text, parseMode, formattingEntities, linkPreview, file, forceDocument, buttons, schedule, }: EditMessageParams): Promise<Api.TypeUpdates>;
export {};
